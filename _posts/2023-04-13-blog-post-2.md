---
title: 'Continuous Updates: R Tricks I Found Useful'
date: 2023-04-14
permalink: /posts/2023/04/blog-post-2/
tags:
  - R Tricks
  - R Examples
---
║█║▌║█║▌ **Latest update 04/17/23: base::sapply() vs base::lapply()** ║█║▌║█║▌

Welcome to this continuously updated blog post where I'll be sharing R tips and tricks that I find helpful while coding. These range from simple one-liners to more complex functions that can save you time and effort. Some of the examples below may be too specific and not useful to you, while others are general R tips. I'm always interested in finding efficient solutions to complex problems and simplifying my code. In this post, you'll find useful R tricks that have helped me boost my coding process and increase productivity. I decided to regularly update this post because I sometimes forget how to code something or how a particular code worked over time. By updating this post regularly, I can stay organized and make it easy to search for code examples in case I encounter similar problems later. Hopefully, you'll find something useful in this post too. 

ଘ(੭*ˊᵕˋ)੭* Stay tuned and happy coding! 
### 1. dplyr::filter()
```{r}
df <- data.frame(Letter = c("A","A","B","C","D"), Count = c(1,2,1,1,1))
df
```
```
  Letter Count
1      A     1
2      A     2
3      B     1
4      C     1
5      D     1
```
Goal: select rows in df where Letter is A and count is 1. e.g.
```
  Letter Count
1      A     1
```
* Method 1:
```{r}
suppressWarnings(df[which(df$Letter == "A" && df$Count == 1), ])
```
* Method 2:
```{r}
library("dplyr")
df %>% 
   dplyr::filter(Letter == "A" & Count == 1)
```

Average time comparison of two methods above under 100 replications: 

Method 1: 0.00019 secs vs. Method 2: 0.00094 secs. Although Method 1 runs slightly faster in this mini example, Method 2 is easier to code. Also, it's important to note that without using suppressWarnings(), Method 1 would return a warning message due to calling "&&". See this [link](https://cran.r-project.org/doc/manuals/r-devel/NEWS.html) for more details.

![image](https://user-images.githubusercontent.com/129143119/232280019-8bf7ae6d-5ae1-4519-b4f4-e53142894e35.png)


### 2. base::outer() 
Goal: generate variance covariance matrix $\Sigma$, where $\Sigma=(\sigma_{jk})\_{jk}$ with $\sigma_{jk} = 0.5^{|j-k|}$ for $j,k = 1,\ldots,5$. e.g.

```
       [,1]  [,2] [,3]  [,4]   [,5]
[1,] 1.0000 0.500 0.25 0.125 0.0625
[2,] 0.5000 1.000 0.50 0.250 0.1250
[3,] 0.2500 0.500 1.00 0.500 0.2500
[4,] 0.1250 0.250 0.50 1.000 0.5000
[5,] 0.0625 0.125 0.25 0.500 1.0000
```
* Method 1:
```{r}
  MA <- matrix(0,5,5)
  for (j in 1:5) {
    for (k in 1:5) {
      MA[j,k]<-0.5^(abs(j-k))
    }
  }
```
* Method 2:
```{r}
matrix((0.5)^(abs(outer(1:5, 1:5, "-"))), nrow = 5, ncol = 5)
```

Average time comparison of two methods above under 100 replications: 

Method 1: $4.67\times 10^{-5}$ secs vs. Method 2: $3.26\times 10^{-5}$ secs. In this mini example, Method 2 has a faster average running time and fewer lines of code than Method 1. Moreover, if we replace 5 with a much larger number, Method 2 will run even faster compared to Method 1. 

### 3. base::split()
```{r}
library(datasets)
data(iris)
table(iris$Species)
```
```
    setosa versicolor  virginica 
        50         50         50 
```
Goal: divide rows in iris into three groups using Species e.g. we are expecting to see 50 rows in each group.

* Solution:
```{r}
split(iris, iris$Species)
```

### 4. base::sapply() vs base::lapply(). 
* What's the difference between sapply() and lapply()? 

The two functions take the same input arguments but return different object classes. 
* lapply() always returns a list.
* sapply() returns a vector or matrix. 

Goal: using data iris, calculate mean of Sepal.Length under each Specie.

* sapply()
```{r}
sapply(temp, function(x) mean(x$Sepal.Length))
```
```
    setosa versicolor  virginica 
     5.006      5.936      6.588 
```

```{r}
class(sapply(temp, function(x) mean(x$Sepal.Length)))
```
```
[1] "numeric"
```

* lapply()
```{r}
lapply(temp, function(x) mean(x$Sepal.Length))
```
```
$setosa
[1] 5.006

$versicolor
[1] 5.936

$virginica
[1] 6.588
```

```{r}
class(lapply(temp, function(x) mean(x$Sepal.Length)))
```

```
[1] "list"
```
I'm interested to see the running time of using a for loop versus the the function from apply family. Rumor said that the apply function runs faster than for loops, and while it is true that for loops typically require more lines of code than those using apply. However, in terms of running time, we will see. This is something that will be addressed later in this post.
